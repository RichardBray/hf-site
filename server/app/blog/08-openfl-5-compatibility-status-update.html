<!DOCTYPE html><html lang="en" class="__className_9318ce"><head><link rel="preload" href="/_next/static/media/f884d4ea94220255.p.woff2" as="font" type="font/woff2" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/97bdc754440853c7.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/b76f6b40b08cf2ac.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/464b40a213f0faa2.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/b8f6d7805f6cf732.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/3966fc2c7f21f103.css" data-precedence="high"/><script async="" src="https://platform.twitter.com/widgets.js" charSet="utf-8"></script><title>HaxeFlixel.com</title><meta name="description" content="HaxeFlixel is a 2D Game Engine that lets you create cross-platform games easier with free, open source technology!"/><meta name="keywords" content="gamedev, game development, cross-platform, haxe, flixel"/><link rel="icon" href="/images/favicon.ico"/><script defer="" src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" nomodule=""></script></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img alt="HaxeFlixel" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=256&amp;q=75" width="100" height="100" decoding="async" data-nimg="1" loading="lazy" style="color:transparent;width:169px;height:30px"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li class="dropdown "><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Examples <span class="caret"></span></a><ul class="dropdown-menu inverse-dropdown"><li><a href="/demos">Demos</a></li><li><a href="https://snippets.haxeflixel.com/">Snippets</a></li></ul></li><li><a href="/showcase">Showcase</a></li><li><a href="/blog">Blog</a></li><li><a href="/documentation">Docs</a></li><li><a href="http://api.haxeflixel.com">API</a></li><li><a href="https://github.com/HaxeFlixel/flixel/discussions">Forum</a></li></ul></div></div></div><main><div data-nextjs-scroll-focus-boundary=""><div data-nextjs-scroll-focus-boundary=""><div data-nextjs-scroll-focus-boundary=""><div class="container container-main"><div class="col-md-8"><h1 class="title">OpenFL 5 compatibility status update</h1><p class="styles_post-date__mNLdb">May 13, 2017</p><p>Hey, Beeblerox here!</p>
<p>As you may know, HaxeFlixel is currently stuck with outdated versions of OpenFL and Lime due to some rendering incompatibilities, and updating it has turned out to be more work than expected. I want to give you a quick status update regarding my work towards making Flixel compatible with the latest versions of OpenFL again.</p>
<p><strong>Note:</strong> I&#x27;ve switched to working on a new branch and closed the <a href="https://github.com/HaxeFlixel/flixel/pull/2032">previous pull request</a>. You can follow my progress in the new pull request <a href="https://github.com/HaxeFlixel/flixel/pull/2068">here</a>.</p>
<h3>FlxMaterial</h3>
<p>I&#x27;ve added a <code>FlxMaterial</code> class (see <a href="https://github.com/Beeblerox/flixel/blob/939a61d8f5b5e952324cdc5b80a1de3f13952956/flixel/graphics/FlxMaterial.hx">here</a>). Currently, it&#x27;s just a single render-pass material with multiple textures support. This enables more complex effects like 2D-lighting (by using normal maps generated with tools like <a href="https://www.codeandweb.com/spriteilluminator">SpriteIlluminator</a>). I&#x27;ve updated the <a href="https://github.com/Pixelbear/flixelighting">flixelighting lib</a> by <a href="https://github.com/Pixelbear">Pixelbear</a> to make it work with the new material system on my fork <a href="https://github.com/Beeblerox/flixelighting/tree/FlxMaterial/lighting">here</a>.</p>
<p>Here is an example of how it can be used right now:</p>
<pre><code class="language-haxe">// create regular sprite
shadedWall = new FlxSprite(100, 200, &quot;assets/rock.png&quot;);
add(shadedWall);
// create custom lighting material and apply to our sprite
lightMaterial = new FlxLightingMaterial();
teapot.material = lightMaterial;
// tune light material properties
lightMaterial.setAmbient(FlxColor.YELLOW, 0.2);
// add light source
light = new FlxLight(0, 0, 0.3);
light.lightColor = FlxColor.WHITE;
add(light);
lightMaterial.addLight(light);
// and create normal map and apply it to our material
var normalMap:FlxNormalMap = new FlxNormalMap(0, 0, &quot;assets/rock_n.png&quot;);
lightMaterial.addNormalMap(normalMap);
</code></pre>
<p>And here is the result:</p>
<p><img src="/images/blog/openfl5/lighting.jpg" alt=""/></p>
<p>Now a few more details about sprite materials.</p>
<p>Each sprite, tilemap, etc. now has a <code>material:FlxMaterial</code> property. A material stores information about an object&#x27;s blend mode, smoothing, shader to use, data for the shader (values of shader uniforms) and an array of textures to use. So when you do <code>sprite.blend = BlendMode.ADD;</code>, in reality you change the blend mode <em>of its material</em>.</p>
<p>By default, objects have materials without shaders (shader is <code>null</code>), which means that the renderer will use default shader and batch this object. If you do set a material&#x27;s shader property, then the material will create a data object (<code>openfl.display.ShaderData</code>) to store info about shader uniforms which you could set later. Say your shader has a <code>uFill</code> uniform after setting <code>material.shader = myCustomShader</code>, you can set the value of this uniform like this:</p>
<pre><code class="language-haxe">material.data.uFill.value = [0.5];
</code></pre>
<p>Setting a material&#x27;s shader you will break the batch, but if several sprites share the same material, then they will be batched together again.</p>
<p>The material class also has a <code>batchable:Bool</code> property which is <code>true</code> by default. This means that the renderer will try to batch objects with this material. But in case you have many sprites with different materials and you want them <em>not</em> to be batched (to minimize the amount of data which will be reuploaded to the GPU), you could set it to <code>false</code> to force this behavior (<code>sprite.material.batchable = false;</code>).</p>
<h3>Multipass</h3>
<p>For more complex effects which require multi-pass rendering, I&#x27;ve added <code>FlxRenderTarget</code> which extends the <code>FlxSprite</code> class. Basically it&#x27;s the same as a <code>FlxSprite</code>, but you can render other sprites to its texture through underlying OpenGL calls (not with BitmapData&#x27;s <code>draw()</code> method). I took the idea from <a href="https://github.com/photonstorm/phaser/blob/master/v3/src/gameobjects/renderpass/RenderPass.js">Phaser&#x27;s RenderPass object</a>, which has a very simple API. Here is a usage example for it:</p>
<pre><code class="language-haxe">// create render target with the size of 256 by 512 pixels
var renderTexture:FlxRenderTarget = new FlxRenderTarget(256, 512);
// specify camera which will be used for calculation of drawable sprites positions on this render texture.
renderTexture.renderCamera = FlxG.camera;
add(renderTexture);
// set object&#x27;s renderTarget, so it will be rendered only on its texture and won&#x27;t appear on any camera.
teapot.renderTarget = renderTexture;
// set render pass shader.
renderTexture.shader = myCustomShader;
</code></pre>
<h3>Camera buffers</h3>
<p>Since the first iteration of the new renderer I&#x27;ve changed a lot of things. The biggest of them is the way objects are rendered to the camera and to the screen. Now, each camera has its own render texture to which all object are rendered, and then this texture is rendered to the screen.</p>
<p><img src="/images/blog/openfl5/cameraBuffers.jpg" alt=""/></p>
<p>This way of rendering helps minimize the number of array iterations, and also made it much easier for other features to be implemented (such as the <code>FlxRenderTarget</code> class).</p>
<h3>Debug rendering</h3>
<p>I was disappointed by the performance of <code>drawDebug</code> rendering on native targets, so I&#x27;ve redone it and now it uses OpenGL instead of OpenFL&#x27;s <code>Graphics</code> API.</p>
<p><img src="/images/blog/openfl5/drawDebug.jpg" alt=""/></p>
<h3>drawTriangles()</h3>
<p>Last weekend I was busy with rewriting the <code>FlxStrip</code> and <code>FlxTrianglesData</code> classes. They are responsible for rendering complex meshes having hundreds of vertices.
As you may know, <code>FlxStrip</code> is a subclass of <code>FlxSprite</code>. It&#x27;s only purpose was to call the <code>drawTriangles()</code> method with <code>vertices</code>, <code>uvs</code>, <code>indices</code> and <code>colors</code> arguments specified by the user. Now, it&#x27;s become much more flexible and easier to use for prototyping.
Each <code>FlxStrip</code> object has a <code>data:FlxTrianglesData</code> property which stores information about added vertices. In addition to getters and setters for <code>vertices</code>, <code>indices</code>, etc., it now has utility methods for adding a single vertex and a single triangle:</p>
<pre><code class="language-haxe">var data:FlxTrianglesData = mySprite.data;
// set vertices info in old way
data.vertices = Vector.ofArray([0.0, 0.0, 100.0, 0.0, 0.0, 100.0]);
data.colors = Vector.ofArray([FlxColor.RED, FlxColor.GREEN, FlxColor.BLUE]);
data.indices = Vector.ofArray([0, 1, 2]);
// and you can add it new way
data.start();
data.addVertex(200, 300, 0, 0, FlxColor.RED);
data.addVertex(300, 300, 0, 0, FlxColor.GREEN);
data.addVertex(200, 400, 0, 0, FlxColor.BLUE);
data.addTriangle(0, 1, 2);

// plus you can change data of individual vertex
data.setVertex(0, newX, newY, 0.0, 0.0, newColor);
</code></pre>
<p>This new API allows to minimize the iterations through inner data arrays which will be uploaded to GPU, which should result in a noticeable performance improvement.
I also borrowed HaxePunk&#x27;s code for GPU-accelerated rendering of graphics primitives (<a href="https://github.com/MattTuttle/HaxePunk/blob/draw-hardware/haxepunk/utils/Draw.hx"><code>Draw</code> class</a>) and adapted it to Flixel, so there is new <code>FlxDraw</code> class for rendering lines, rectangle, circles, polygons and curves.</p>
<p><img src="/images/blog/openfl5/drawTriangles.png" alt=""/></p>
<h3>Next steps</h3>
<p>Next, I&#x27;ll start updating the flixel-addons classes and demos. Meanwhile, I&#x27;d be happy about any feedback you have for me - please post it in the <a href="https://github.com/HaxeFlixel/flixel/pull/2068">OpenFL 5 compatibility pull request</a>!</p><br/><hr/><br/></div></div></div></div></div></main><footer class="footer"><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameBorder="0" src="https://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><a class="footer-patreon" href="https://www.patreon.com/haxeflixel" title="Support us on Patreon"><img alt="Haxeflixel Patreon" title="Patreon" srcSet="/images/patreon-logo-small.svg 1x, /images/patreon-logo-small.svg 2x" src="/images/patreon-logo-small.svg" width="40" height="40" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="http://haxe.org"><img alt="Haxe" title="Haxe" srcSet="/images/haxe.svg 1x, /images/haxe.svg 2x" src="/images/haxe.svg" width="40" height="40" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>+<a href="http://openfl.org"><img alt="OpenFL" title="OpenFL" srcSet="/images/openfl.svg 1x, /images/openfl.svg 2x" src="/images/openfl.svg" width="40" height="40" decoding="async" data-nimg="1" class="openfl-footer-logo" loading="lazy" style="color:transparent"/></a>+<a href="http://flixel.org"><img alt="Flixel" title="Flixel" srcSet="/images/flixel.svg 1x, /images/flixel.svg 2x" src="/images/flixel.svg" width="40" height="40" decoding="async" data-nimg="1" class="flixel-footer-logo" loading="lazy" style="color:transparent"/></a></div></div></div></footer><script src="/_next/static/chunks/webpack-6588fe9a4e0ab52a.js" async=""></script><script src="/_next/static/chunks/17-2fbad5a8fc7a3fb9.js" async=""></script><script src="/_next/static/chunks/main-app-f7991bdf5a7d528d.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"M1:{\"id\":\"7954\",\"name\":\"\",\"chunks\":[\"272:webpack-6588fe9a4e0ab52a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d\"],\"async\":false}\nM2:{\"id\":\"4090\",\"name\":\"\",\"chunks\":[\"30:30-b47b7e3ef59158d9\",\"90:90-19e2035b40cf9494\",\"931:app/page-cbee7de8152e1b3e\"],\"async\":false}\nM3:{\"id\":\"30\",\"name\":\"\",\"chunks\":[\"30:30-b47b7e3ef59158d9\",\"976:app/sponsors/page-5aaa65efc5d7a9a6\"],\"async\":false}\nM4:{\"id\":\"9875\",\"name\":\"\",\"chunks\":[\"272:webpack-6588fe9a4e0ab52a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d"])</script><script>self.__next_f.push([1,"\"],\"async\":false}\nM5:{\"id\":\"2092\",\"name\":\"\",\"chunks\":[\"272:webpack-6588fe9a4e0ab52a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d\"],\"async\":false}\n"])</script><script>self.__next_f.push([1,"J0:[\"$\",\"@1\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/08-openfl-5-compatibility-status-update\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"blogPost\",\"08-openfl-5-compatibility-status-update\",\"d\"],{\"children\":[\"\",{}]}]}]},null,null,true],\"initialHead\":null,\"children\":[[[\"$\",\"link\",\"static/media/f884d4ea94220255.p.woff2\",{\"rel\":\"preload\",\"href\":\"/_next/static/media/f884d4ea94220255.p.woff2\",\"as\":\"font\",\"type\":\"font/woff2\",\"crossOrigin\":\"anonymous\"}]],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/97bdc754440853c7.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b76f6b40b08cf2ac.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/464b40a213f0faa2.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b8f6d7805f6cf732.css\",\"precedence\":\"high\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"__className_9318ce\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"title\",null,{\"children\":\"HaxeFlixel.com\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"HaxeFlixel is a 2D Game Engine that lets you create cross-platform games easier with free, open source technology!\"}],[\"$\",\"meta\",null,{\"name\":\"keywords\",\"content\":\"gamedev, game development, cross-platform, haxe, flixel\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/images/favicon.ico\"}],[\"$\",\"script\",null,{\"defer\":true,\"src\":\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"}],[\"$\",\"script\",null,{\"defer\":true,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://platform.twitter.com/widgets.js\",\"charSet\":\"utf-8\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"navbar navbar-inverse navbar-fixed-top\",\"children\":[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"navbar-header\",\"children\":[[\"$\",\"button\",null,{\"data-target\":\".navbar-collapse\",\"data-toggle\":\"collapse\",\"className\":\"navbar-toggle\",\"type\":\"button\",\"children\":[[\"$\",\"span\",null,{\"className\":\"icon-bar\"}],[\"$\",\"span\",null,{\"className\":\"icon-bar\"}],[\"$\",\"span\",null,{\"className\":\"icon-bar\"}]]}],[\"$\",\"@2\",null,{\"href\":\"/\",\"className\":\"navbar-brand\",\"children\":[\"$\",\"@3\",null,{\"src\":{\"src\":\"/_next/static/media/haxeflixel-header.19d77213.png\",\"height\":30,\"width\":169,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAYAAADjAO9DAAAAJklEQVR4nGPsXzz5rSSvbF24v//e379/87OwsDAyMDD8A2IQ/RkAzmIKJsmSsVcAAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":1},\"style\":{\"width\":\"169px\",\"height\":\"30px\"},\"alt\":\"HaxeFlixel\",\"width\":\"100\",\"height\":\"100\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"navbar-collapse collapse\",\"children\":[\"$\",\"ul\",null,{\"className\":\"nav navbar-nav\",\"children\":[[\"$\",\"li\",null,{\"className\":\"dropdown \",\"children\":[[\"$\",\"a\",null,{\"href\":\"#\",\"className\":\"dropdown-toggle\",\"data-toggle\":\"dropdown\",\"role\":\"button\",\"aria-haspopup\":\"true\",\"aria-expanded\":\"false\",\"children\":[\"Examples \",[\"$\",\"span\",null,{\"className\":\"caret\"}]]}],[\"$\",\"ul\",null,{\"className\":\"dropdown-menu inverse-dropdown\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/demos\",\"children\":\"Demos\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://snippets.haxeflixel.com/\",\"children\":\"Snippets\"}]}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/showcase\",\"children\":\"Showcase\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/blog\",\"children\":\"Blog\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/documentation\",\"children\":\"Docs\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"http://api.haxeflixel.com\",\"children\":\"API\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/HaxeFlixel/flixel/discussions\",\"children\":\"Forum\"}]}]]}]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"notFound\":[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"-apple-system, BlinkMacSystemFont, Roboto, \\\"Segoe UI\\\", \\\"Fira Sans\\\", Avenir, \\\"Helvetica Neue\\\", \\\"Lucida Grande\\\", sans-serif\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n            body { margin: 0; color: #000; background: #fff; }\\n            .next-error-h1 {\\n              border-right: 1px solid rgba(0, 0, 0, .3);\\n            }\\n\\n            @media (prefers-color-scheme: dark) {\\n              body { color: #fff; background: #000; }\\n              .next-error-h1 {\\n                border-right: 1px solid rgba(255, 255, 255, .3);\\n              }\\n            }\\n          \"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":0,\"marginRight\":\"20px\",\"padding\":\"0 23px 0 0\",\"fontSize\":\"24px\",\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\",\"textAlign\":\"left\",\"lineHeight\":\"49px\",\"height\":\"49px\",\"verticalAlign\":\"middle\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":\"14px\",\"fontWeight\":\"normal\",\"lineHeight\":\"49px\",\"margin\":0,\"padding\":0},\"children\":\"This page could not be found.\"}]}]]}]]}],\"childProp\":{\"current\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"childProp\":{\"current\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"blogPost\",\"08-openfl-5-compatibility-status-update\",\"d\"],\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"childProp\":{\"current\":[[],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3966fc2c7f21f103.css\",\"precedence\":\"high\"}]],\"@6\"],\"segment\":\"\"},\"rootLayoutIncluded\":true}],\"segment\":[\"blogPost\",\"08-openfl-5-compatibility-status-update\",\"d\"]},\"rootLayoutIncluded\":true}],\"segment\":\"blog\"},\"rootLayoutIncluded\":true}]}],[\"$\",\"footer\",null,{\"className\":\"footer\",\"children\":[\"$\",\"div\",null,{\"className\":\"footer-main\",\"children\":[\"$\",\"div\",null,{\"className\":\" container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"footer-social\",\"children\":[[\"$\",\"iframe\",null,{\"width\":\"120px\",\"scrolling\":\"0\",\"height\":\"20px\",\"frameBorder\":\"0\",\"src\":\"https://ghbtns.com/github-btn.html?user=HaxeFlixel\u0026repo=flixel\u0026type=watch\u0026count=true\u0026size=small\"}],[\"$\",\"a\",null,{\"href\":\"https://twitter.com/haxeflixel\",\"className\":\"twitter-follow-button\",\"data-show-count\":\"true\",\"data-lang\":\"en\",\"data-size\":\"small\",\"children\":\"Follow @haxeflixel\"}],[\"$\",\"a\",null,{\"className\":\"footer-patreon\",\"href\":\"https://www.patreon.com/haxeflixel\",\"title\":\"Support us on Patreon\",\"children\":[\"$\",\"@3\",null,{\"src\":\"/images/patreon-logo-small.svg\",\"alt\":\"Haxeflixel Patreon\",\"title\":\"Patreon\",\"width\":\"40\",\"height\":\"40\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"footer-powered-by\",\"children\":[[\"$\",\"p\",null,{\"children\":\"HaxeFlixel is powered by\"}],[\"$\",\"a\",null,{\"href\":\"http://haxe.org\",\"children\":[\"$\",\"@3\",null,{\"src\":\"/images/haxe.svg\",\"alt\":\"Haxe\",\"title\":\"Haxe\",\"width\":\"40\",\"height\":\"40\"}]}],\"+\",[\"$\",\"a\",null,{\"href\":\"http://openfl.org\",\"children\":[\"$\",\"@3\",null,{\"className\":\"openfl-footer-logo\",\"src\":\"/images/openfl.svg\",\"alt\":\"OpenFL\",\"title\":\"OpenFL\",\"width\":\"40\",\"height\":\"40\"}]}],\"+\",[\"$\",\"a\",null,{\"href\":\"http://flixel.org\",\"children\":[\"$\",\"@3\",null,{\"className\":\"flixel-footer-logo\",\"src\":\"/images/flixel.svg\",\"alt\":\"Flixel\",\"title\":\"Flixel\",\"width\":\"40\",\"height\":\"40\"}]}]]}]]}]}]}]]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"M7:{\"id\":\"3108\",\"name\":\"\",\"chunks\":[\"277:app/blog/[blogPost]/page-d2eac13d9ceb2814\"],\"async\":false}\n"])</script><script>self.__next_f.push([1,"J6:[\"$\",\"@7\",null,{\"frontMatter\":{\"title\":\"OpenFL 5 compatibility status update\",\"layout\":\"blog-post\",\"postDate\":\"May 13, 2017\"},\"html\":{\"compiledSource\":\"/*@jsxRuntime automatic @jsxImportSource react*/\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nconst {useMDXComponents: _provideComponents} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = Object.assign({\\n    p: \\\"p\\\",\\n    strong: \\\"strong\\\",\\n    a: \\\"a\\\",\\n    h3: \\\"h3\\\",\\n    code: \\\"code\\\",\\n    pre: \\\"pre\\\",\\n    img: \\\"img\\\",\\n    em: \\\"em\\\"\\n  }, _provideComponents(), props.components);\\n  return _jsxs(_Fragment, {\\n    children: [_jsx(_components.p, {\\n      children: \\\"Hey, Beeblerox here!\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"As you may know, HaxeFlixel is currently stuck with outdated versions of OpenFL and Lime due to some rendering incompatibilities, and updating it has turned out to be more work than expected. I want to give you a quick status update regarding my work towards making Flixel compatible with the latest versions of OpenFL again.\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [_jsx(_components.strong, {\\n        children: \\\"Note:\\\"\\n      }), \\\" I've switched to working on a new branch and closed the \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/HaxeFlixel/flixel/pull/2032\\\",\\n        children: \\\"previous pull request\\\"\\n      }), \\\". You can follow my progress in the new pull request \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/HaxeFlixel/flixel/pull/2068\\\",\\n        children: \\\"here\\\"\\n      }), \\\".\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"FlxMaterial\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"I've added a \\\", _jsx(_components.code, {\\n        children: \\\"FlxMaterial\\\"\\n      }), \\\" class (see \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/Beeblerox/flixel/blob/939a61d8f5b5e952324cdc5b80a1de3f13952956/flixel/graphics/FlxMaterial.hx\\\",\\n        children: \\\"here\\\"\\n      }), \\\"). Currently, it's just a single render-pass material with multiple textures support. This enables more complex effects like 2D-lighting (by using normal maps generated with tools like \\\", _jsx(_components.a, {\\n        href: \\\"https://www.codeandweb.com/spriteilluminator\\\",\\n        children: \\\"SpriteIlluminator\\\"\\n      }), \\\"). I've updated the \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/Pixelbear/flixelighting\\\",\\n        children: \\\"flixelighting lib\\\"\\n      }), \\\" by \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/Pixelbear\\\",\\n        children: \\\"Pixelbear\\\"\\n      }), \\\" to make it work with the new material system on my fork \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/Beeblerox/flixelighting/tree/FlxMaterial/lighting\\\",\\n        children: \\\"here\\\"\\n      }), \\\".\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Here is an example of how it can be used right now:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        className: \\\"language-haxe\\\",\\n        children: \\\"// create regular sprite\\\\nshadedWall = new FlxSprite(100, 200, \\\\\\\"assets/rock.png\\\\\\\");\\\\nadd(shadedWall);\\\\n// create custom lighting material and apply to our sprite\\\\nlightMaterial = new FlxLightingMaterial();\\\\nteapot.material = lightMaterial;\\\\n// tune light material properties\\\\nlightMaterial.setAmbient(FlxColor.YELLOW, 0.2);\\\\n// add light source\\\\nlight = new FlxLight(0, 0, 0.3);\\\\nlight.lightColor = FlxColor.WHITE;\\\\nadd(light);\\\\nlightMaterial.addLight(light);\\\\n// and create normal map and apply it to our material\\\\nvar normalMap:FlxNormalMap = new FlxNormalMap(0, 0, \\\\\\\"assets/rock_n.png\\\\\\\");\\\\nlightMaterial.addNormalMap(normalMap);\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"And here is the result:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: _jsx(_components.img, {\\n        src: \\\"/images/blog/openfl5/lighting.jpg\\\",\\n        alt: \\\"\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Now a few more details about sprite materials.\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Each sprite, tilemap, etc. now has a \\\", _jsx(_components.code, {\\n        children: \\\"material:FlxMaterial\\\"\\n      }), \\\" property. A material stores information about an object's blend mode, smoothing, shader to use, data for the shader (values of shader uniforms) and an array of textures to use. So when you do \\\", _jsx(_components.code, {\\n        children: \\\"sprite.blend = BlendMode.ADD;\\\"\\n      }), \\\", in reality you change the blend mode \\\", _jsx(_components.em, {\\n        children: \\\"of its material\\\"\\n      }), \\\".\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"By default, objects have materials without shaders (shader is \\\", _jsx(_components.code, {\\n        children: \\\"null\\\"\\n      }), \\\"), which means that the renderer will use default shader and batch this object. If you do set a material's shader property, then the material will create a data object (\\\", _jsx(_components.code, {\\n        children: \\\"openfl.display.ShaderData\\\"\\n      }), \\\") to store info about shader uniforms which you could set later. Say your shader has a \\\", _jsx(_components.code, {\\n        children: \\\"uFill\\\"\\n      }), \\\" uniform after setting \\\", _jsx(_components.code, {\\n        children: \\\"material.shader = myCustomShader\\\"\\n      }), \\\", you can set the value of this uniform like this:\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        className: \\\"language-haxe\\\",\\n        children: \\\"material.data.uFill.value = [0.5];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Setting a material's shader you will break the batch, but if several sprites share the same material, then they will be batched together again.\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"The material class also has a \\\", _jsx(_components.code, {\\n        children: \\\"batchable:Bool\\\"\\n      }), \\\" property which is \\\", _jsx(_components.code, {\\n        children: \\\"true\\\"\\n      }), \\\" by default. This means that the renderer will try to batch objects with this material. But in case you have many sprites with different materials and you want them \\\", _jsx(_components.em, {\\n        children: \\\"not\\\"\\n      }), \\\" to be batched (to minimize the amount of data which will be reuploaded to the GPU), you could set it to \\\", _jsx(_components.code, {\\n        children: \\\"false\\\"\\n      }), \\\" to force this behavior (\\\", _jsx(_components.code, {\\n        children: \\\"sprite.material.batchable = false;\\\"\\n      }), \\\").\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Multipass\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"For more complex effects which require multi-pass rendering, I've added \\\", _jsx(_components.code, {\\n        children: \\\"FlxRenderTarget\\\"\\n      }), \\\" which extends the \\\", _jsx(_components.code, {\\n        children: \\\"FlxSprite\\\"\\n      }), \\\" class. Basically it's the same as a \\\", _jsx(_components.code, {\\n        children: \\\"FlxSprite\\\"\\n      }), \\\", but you can render other sprites to its texture through underlying OpenGL calls (not with BitmapData's \\\", _jsx(_components.code, {\\n        children: \\\"draw()\\\"\\n      }), \\\" method). I took the idea from \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/photonstorm/phaser/blob/master/v3/src/gameobjects/renderpass/RenderPass.js\\\",\\n        children: \\\"Phaser's RenderPass object\\\"\\n      }), \\\", which has a very simple API. Here is a usage example for it:\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        className: \\\"language-haxe\\\",\\n        children: \\\"// create render target with the size of 256 by 512 pixels\\\\nvar renderTexture:FlxRenderTarget = new FlxRenderTarget(256, 512);\\\\n// specify camera which will be used for calculation of drawable sprites positions on this render texture.\\\\nrenderTexture.renderCamera = FlxG.camera;\\\\nadd(renderTexture);\\\\n// set object's renderTarget, so it will be rendered only on its texture and won't appear on any camera.\\\\nteapot.renderTarget = renderTexture;\\\\n// set render pass shader.\\\\nrenderTexture.shader = myCustomShader;\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Camera buffers\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Since the first iteration of the new renderer I've changed a lot of things. The biggest of them is the way objects are rendered to the camera and to the screen. Now, each camera has its own render texture to which all object are rendered, and then this texture is rendered to the screen.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: _jsx(_components.img, {\\n        src: \\\"/images/blog/openfl5/cameraBuffers.jpg\\\",\\n        alt: \\\"\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"This way of rendering helps minimize the number of array iterations, and also made it much easier for other features to be implemented (such as the \\\", _jsx(_components.code, {\\n        children: \\\"FlxRenderTarget\\\"\\n      }), \\\" class).\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Debug rendering\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"I was disappointed by the performance of \\\", _jsx(_components.code, {\\n        children: \\\"drawDebug\\\"\\n      }), \\\" rendering on native targets, so I've redone it and now it uses OpenGL instead of OpenFL's \\\", _jsx(_components.code, {\\n        children: \\\"Graphics\\\"\\n      }), \\\" API.\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: _jsx(_components.img, {\\n        src: \\\"/images/blog/openfl5/drawDebug.jpg\\\",\\n        alt: \\\"\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"drawTriangles()\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Last weekend I was busy with rewriting the \\\", _jsx(_components.code, {\\n        children: \\\"FlxStrip\\\"\\n      }), \\\" and \\\", _jsx(_components.code, {\\n        children: \\\"FlxTrianglesData\\\"\\n      }), \\\" classes. They are responsible for rendering complex meshes having hundreds of vertices.\\\\nAs you may know, \\\", _jsx(_components.code, {\\n        children: \\\"FlxStrip\\\"\\n      }), \\\" is a subclass of \\\", _jsx(_components.code, {\\n        children: \\\"FlxSprite\\\"\\n      }), \\\". It's only purpose was to call the \\\", _jsx(_components.code, {\\n        children: \\\"drawTriangles()\\\"\\n      }), \\\" method with \\\", _jsx(_components.code, {\\n        children: \\\"vertices\\\"\\n      }), \\\", \\\", _jsx(_components.code, {\\n        children: \\\"uvs\\\"\\n      }), \\\", \\\", _jsx(_components.code, {\\n        children: \\\"indices\\\"\\n      }), \\\" and \\\", _jsx(_components.code, {\\n        children: \\\"colors\\\"\\n      }), \\\" arguments specified by the user. Now, it's become much more flexible and easier to use for prototyping.\\\\nEach \\\", _jsx(_components.code, {\\n        children: \\\"FlxStrip\\\"\\n      }), \\\" object has a \\\", _jsx(_components.code, {\\n        children: \\\"data:FlxTrianglesData\\\"\\n      }), \\\" property which stores information about added vertices. In addition to getters and setters for \\\", _jsx(_components.code, {\\n        children: \\\"vertices\\\"\\n      }), \\\", \\\", _jsx(_components.code, {\\n        children: \\\"indices\\\"\\n      }), \\\", etc., it now has utility methods for adding a single vertex and a single triangle:\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        className: \\\"language-haxe\\\",\\n        children: \\\"var data:FlxTrianglesData = mySprite.data;\\\\n// set vertices info in old way\\\\ndata.vertices = Vector.ofArray([0.0, 0.0, 100.0, 0.0, 0.0, 100.0]);\\\\ndata.colors = Vector.ofArray([FlxColor.RED, FlxColor.GREEN, FlxColor.BLUE]);\\\\ndata.indices = Vector.ofArray([0, 1, 2]);\\\\n// and you can add it new way\\\\ndata.start();\\\\ndata.addVertex(200, 300, 0, 0, FlxColor.RED);\\\\ndata.addVertex(300, 300, 0, 0, FlxColor.GREEN);\\\\ndata.addVertex(200, 400, 0, 0, FlxColor.BLUE);\\\\ndata.addTriangle(0, 1, 2);\\\\n\\\\n// plus you can change data of individual vertex\\\\ndata.setVertex(0, newX, newY, 0.0, 0.0, newColor);\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"This new API allows to minimize the iterations through inner data arrays which will be uploaded to GPU, which should result in a noticeable performance improvement.\\\\nI also borrowed HaxePunk's code for GPU-accelerated rendering of graphics primitives (\\\", _jsxs(_components.a, {\\n        href: \\\"https://github.com/MattTuttle/HaxePunk/blob/draw-hardware/haxepunk/utils/Draw.hx\\\",\\n        children: [_jsx(_components.code, {\\n          children: \\\"Draw\\\"\\n        }), \\\" class\\\"]\\n      }), \\\") and adapted it to Flixel, so there is new \\\", _jsx(_components.code, {\\n        children: \\\"FlxDraw\\\"\\n      }), \\\" class for rendering lines, rectangle, circles, polygons and curves.\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: _jsx(_components.img, {\\n        src: \\\"/images/blog/openfl5/drawTriangles.png\\\",\\n        alt: \\\"\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.h3, {\\n      children: \\\"Next steps\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"Next, I'll start updating the flixel-addons classes and demos. Meanwhile, I'd be happy about any feedback you have for me - please post it in the \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/HaxeFlixel/flixel/pull/2068\\\",\\n        children: \\\"OpenFL 5 compatibility pull request\\\"\\n      }), \\\"!\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\\n    children: _jsx(_createMdxContent, props)\\n  })) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",\"frontmatter\":{},\"scope\":{}}}]\n"])</script>