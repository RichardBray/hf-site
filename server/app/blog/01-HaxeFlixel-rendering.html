<!DOCTYPE html><html lang="en" class="__className_9318ce"><head><link rel="preload" href="/_next/static/media/f884d4ea94220255.p.woff2" as="font" type="font/woff2" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/97bdc754440853c7.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/b76f6b40b08cf2ac.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/cec42fb6dc8e78d9.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/b8f6d7805f6cf732.css" data-precedence="high"/><link rel="stylesheet" href="/_next/static/css/3966fc2c7f21f103.css" data-precedence="high"/><script async="" src="https://platform.twitter.com/widgets.js" charSet="utf-8"></script><title>HaxeFlixel.com</title><meta name="description" content="HaxeFlixel is a 2D Game Engine that lets you create cross-platform games easier with free, open source technology!"/><meta name="keywords" content="gamedev, game development, cross-platform, haxe, flixel"/><link rel="icon" href="/images/favicon.ico"/><script defer="" src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js" nomodule=""></script></head><body><div class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button data-target=".navbar-collapse" data-toggle="collapse" class="navbar-toggle" type="button"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img alt="HaxeFlixel" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fhaxeflixel-header.19d77213.png&amp;w=256&amp;q=75" width="100" height="100" decoding="async" data-nimg="1" loading="lazy" style="color:transparent;width:169px;height:30px"/></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav"><li class="dropdown "><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Examples <span class="caret"></span></a><ul class="dropdown-menu inverse-dropdown"><li><a href="/demos">Demos</a></li><li><a href="https://snippets.haxeflixel.com/">Snippets</a></li></ul></li><li><a href="/showcase">Showcase</a></li><li><a href="/blog">Blog</a></li><li><a href="/documentation">Docs</a></li><li><a href="http://api.haxeflixel.com">API</a></li><li><a href="https://github.com/HaxeFlixel/flixel/discussions">Forum</a></li></ul></div></div></div><main><div data-nextjs-scroll-focus-boundary=""><div data-nextjs-scroll-focus-boundary=""><div data-nextjs-scroll-focus-boundary=""><div class="container container-main"><div class="col-md-8"><h1 class="title">Tilesheet rendering</h1><p class="styles_post-date__mNLdb">July 31, 2014</p><p>Hi, <a href="https://github.com/gamedevsam">gamedevsam</a> here, I&#x27;m a developer and evangelist of HaxeFlixel.</p>
<p>The following blog post was written by <a href="https://github.com/Beeblerox">Beeblerox</a> (the original creator of HaxeFlixel) and was originally posted on his blog as a two part article (<a href="http://beeblerox.tumblr.com/post/87678385538/tilesheet-rendering-part-1">part 1</a> and <a href="http://beeblerox.tumblr.com/post/87778663958/tilesheet-rendering-part-2-some-details-about-flixel">part 2</a>). In it, he goes into detail on how HaxeFlixel&#x27;s rendering system is built on top of OpenFL&#x27;s Tilesheet API.</p>
<hr/>
<p>I want to tell you about tilesheet rendering in flixel, which is used on native targets by default (since some of you might me intereseted in it).</p>
<p>But let’s start from Tilesheet API and how you work with it (Feel free to skip this part if you know it already).</p>
<p>Tilesheet class allows you to draw multiple regions of image in one drawcall reasonably fast. These regions can be transformed (rotated, scaled, skewed) and tinted, plus they can have several blend modes (the most usefull is addition mode, which can be used for effects like fire and smoke).</p>
<p>Let’s assume that you have some image you want to draw - “assets/tiles.png”.</p>
<p>We are starting from instantiation of Tilesheet object:</p>
<pre><code>tilesheet = new Tilesheet(Assets.getBitmap(“assets/tiles.png”));
</code></pre>
<p>Then we should define region of image (or tile) we want to draw. This is achieved with addTileRect() method, which takes 2 arguments:</p>
<ul>
<li>
<p>the first one is a Rectangle object - it is actual region of image to draw</p>
</li>
<li>
<p>and the second one is a Pont object, which define “center” point of a tile. Added tile will be rotated around this point, if we apply rotation transformation to it. This point should be inside of a tile (or it will be bounded), so if you add tile with the size 32x32 pixels and the center at (50; 16), then actual center point will be at (32; 16).</p>
</li>
</ul>
<p>Center point argument is optional, and if you omit it then tile will be rotated around it’s middle point.</p>
<pre><code>// adding tiles to the tilesheet
tileID1 = tilesheet.addTileRect(newRectangle(0, 0, 32, 32), new Point(16, 16));
tileID2 = tilesheet.addTileRect(newRectangle(32, 0, 32, 32), new Point(16, 16));
</code></pre>
<p>Then we should have some Graphics object to draw our tiles on.</p>
<pre><code>sprite = new Sprite();
Lib.current.stage.addChild(sprite);
graphicsToUse = sprite.graphics;
</code></pre>
<p>To draw the tiles on screen we need three things:</p>
<ol>
<li>
<p>Graphics to draw then on</p>
</li>
<li>
<p>Draw flag which tells to the program what tile transformations we want to use on our tiles in this drawcall.</p>
</li>
</ol>
<p>The simplest case is no transformation (we just draw rectangular region of image on specified position):</p>
<pre><code>drawFlag = 0;
</code></pre>
<p>You can add tinting:</p>
<pre><code>drawFlag |= Tilesheet.TILE_RGB;
</code></pre>
<p>We can add TILE_ALPHA flag to be able to change tile’s alpha:</p>
<pre><code>drawFlag |= Tilesheet.TILE_ALPHA;
</code></pre>
<p>There are also <code>TILE_ROTATION</code> and <code>TILE_SCALE</code> (for uniform tile scaling) constants for “simple” transformations of a tile. But if you want to achieve some more complex transformation (like non-uniform scaling or skewing) then you have <code>TILE_TRANS_2x2</code> constant.</p>
<p>And finally there are <code>TILE_BLEND_ADD</code> constant for addition blending and <code>TILE_SMOOTH</code> for smoothing scaled up graphics.</p>
<ol start="3">
<li>We also need actual information about tile’s type, position and transformation. The second argument of drawTiles() method - data array - is responsible for it.</li>
</ol>
<p>The amount of data for each tile depends on drawFlags value:</p>
<ul>
<li>if drawFlags is 0, then you should specify only tile’s position and id:</li>
</ul>
<pre><code>data = [x1, y1, tileID1, x2, y2, tileID2];
</code></pre>
<ul>
<li>if you’re using uniform scale and rotation then data array will look like this:</li>
</ul>
<pre><code>data = [x1, y1, tileID1, scale1, angle1, x2, y1, tileID2, scale2, angle2];
</code></pre>
<ul>
<li>if you’re adding tinting and alpha:</li>
</ul>
<pre><code>data = [x1, y1, tileID1, scale1, angle1, red1, green1, blue1, alpha1,  x2, y1, tileID2, scale2, angle2, red2, green2, blue2, alpha2];
</code></pre>
<p>where red, green, blue and alpha are values between 0 and 1 (result color of each pixel will be product of these coefficients and original pixel colors).</p>
<ul>
<li>and the most complex case is when you’re using <code>TILE_TRANS_2x2</code>:</li>
</ul>
<pre><code>data = [x, y, tileID1, a, b, c, d, red, green, blue, alpha];
</code></pre>
<p>where (a, b, c, d) are the transfromation matrix coefficients. You can get their values in two ways:</p>
<p>a) by using Matrix class. For example, if you want to have non-uniform scale and rotation for your tile, then you can get it this way:</p>
<pre><code>matrix.identity();
matrix.scale(scaleX, scaleY);
matrix.rotate(angle);
data = [x, y, tileID1, matrix.a, matrix.b, matrix.c, matrix.d, red, green, blue, alpha];
</code></pre>
<p>b) or manually if you want to make some optimizations. That’s why drawing methods in flixels are so bloated - i just wanted to except some redundant calculations from it.</p>
<p>So finally you can draw your tiles on the screen:</p>
<pre><code>tilesheet.drawTiles(graphicsToUse, data, false, drawFlags);
</code></pre>
<hr/>
<p>If you want to see some working example, then i recommend you to look at Tiles sample project in nme library: <a href="https://github.com/haxenme/nme/tree/master/samples/20-Tiles">https://github.com/haxenme/nme/tree/master/samples/20-Tiles</a></p>
<hr/>
<p>Now when we know everything we need about Tilesheet class, it’s time to talk about flixel renderer a bit.</p>
<p>As you remember we need Graphics object to render our tiles. FlxCamera objects contain flashSprite:Sprite variable inside which we have canvas:Sprite which graphics we use for rendering on the camera. We need canvas spite to be nested inside flashSprite for easy camera rotations. So if you don’t plan to implement such feature then you might use just one sprite without nesting.</p>
<p>We also need data to render and render flags, which reflect what types of transformations (like rotation and tinting) apply to rendered tiles. This information is gathered every render cycle: we iterate through each sprite we have in our game. But to keep drawCalls as low as possible we need some sort of batching, which tries to draw everything with the same graphics in one draw call, and when we change graphics it breaks the batch and starts another. This functionality is split between FlxCamera. FlxSprite class and subclasses and DrawStackItem helper class.</p>
<p>DrawStackItem objects store information about current batch: Tilesheet object to use for rendering, draw data array, information about draw flags (do we need to tint our tiles in the batch, or use blending), and the link to next DrawStackItem object (DrawStackItems are organized into linked list). Each camera have _headOfDrawStack variable which is head of DrawStackItems linked list.</p>
<p>FlxSprite draw() method does the following:</p>
<ul>
<li>
<p>it gets DrawStackItem object to use from current FlxCamera. The result of this operation depends on sprite’s graphics, color and blend mode. So if one of these factors isn’t equal to the properties of current DrawStackItem, then current DrawStackItem will be “finalized” (breaks current batch) and new/empty DrawStackItem will be returned to sprite.</p>
</li>
<li>
<p>sprite will add info about itself in current DrawStackItem (positio, tileID, transformation matrix coefficients, tinting and alpha).</p>
</li>
</ul>
<p>After we iterate through all sprites in our game state, game engine start actual render process.</p>
<p>It iterate through each camera, clear graphics of cameras, fill them with background color (with graphics.drawRect() method), and then each camera iterate through its list of DrawStackItems. This iteration stage takes DrawStackItem’s tilesheet, draw data, draw flag and render it with drawTiles() method on camera’s canvas.graphics.</p>
<p>That is how tilesheet rendering works in flixel. Feel free to ask me questions about it.</p>
<hr/>
<p>You can reach Beeblerox on Twitter <a href="https://twitter.com/teormech">@teormech</a>.</p><br/><hr/><br/></div></div></div></div></div></main><footer class="footer"><div class="footer-main"><div class=" container"><div class="footer-social"><iframe width="120px" scrolling="0" height="20px" frameBorder="0" src="https://ghbtns.com/github-btn.html?user=HaxeFlixel&amp;repo=flixel&amp;type=watch&amp;count=true&amp;size=small"></iframe><a href="https://twitter.com/haxeflixel" class="twitter-follow-button" data-show-count="true" data-lang="en" data-size="small">Follow @haxeflixel</a><a class="footer-patreon" href="https://www.patreon.com/haxeflixel" title="Support us on Patreon"><img alt="Haxeflixel Patreon" title="Patreon" srcSet="/images/patreon-logo-small.svg 1x, /images/patreon-logo-small.svg 2x" src="/images/patreon-logo-small.svg" width="40" height="40" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a></div><div class="footer-powered-by"><p>HaxeFlixel is powered by</p><a href="http://haxe.org"><img alt="Haxe" title="Haxe" srcSet="/images/haxe.svg 1x, /images/haxe.svg 2x" src="/images/haxe.svg" width="40" height="40" decoding="async" data-nimg="1" loading="lazy" style="color:transparent"/></a>+<a href="http://openfl.org"><img alt="OpenFL" title="OpenFL" srcSet="/images/openfl.svg 1x, /images/openfl.svg 2x" src="/images/openfl.svg" width="40" height="40" decoding="async" data-nimg="1" class="openfl-footer-logo" loading="lazy" style="color:transparent"/></a>+<a href="http://flixel.org"><img alt="Flixel" title="Flixel" srcSet="/images/flixel.svg 1x, /images/flixel.svg 2x" src="/images/flixel.svg" width="40" height="40" decoding="async" data-nimg="1" class="flixel-footer-logo" loading="lazy" style="color:transparent"/></a></div></div></div></footer><script src="/_next/static/chunks/webpack-a1f980569ac9201a.js" async=""></script><script src="/_next/static/chunks/17-2fbad5a8fc7a3fb9.js" async=""></script><script src="/_next/static/chunks/main-app-f7991bdf5a7d528d.js" async=""></script></body></html><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"M1:{\"id\":\"7954\",\"name\":\"\",\"chunks\":[\"272:webpack-a1f980569ac9201a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d\"],\"async\":false}\nM2:{\"id\":\"4090\",\"name\":\"\",\"chunks\":[\"30:30-b47b7e3ef59158d9\",\"90:90-19e2035b40cf9494\",\"931:app/page-cbee7de8152e1b3e\"],\"async\":false}\nM3:{\"id\":\"30\",\"name\":\"\",\"chunks\":[\"30:30-b47b7e3ef59158d9\",\"21:app/showcase/page-02ff6d3c9697a3a3\"],\"async\":false}\nM4:{\"id\":\"9875\",\"name\":\"\",\"chunks\":[\"272:webpack-a1f980569ac9201a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d\""])</script><script>self.__next_f.push([1,"],\"async\":false}\nM5:{\"id\":\"2092\",\"name\":\"\",\"chunks\":[\"272:webpack-a1f980569ac9201a\",\"17:17-2fbad5a8fc7a3fb9\",\"744:main-app-f7991bdf5a7d528d\"],\"async\":false}\n"])</script><script>self.__next_f.push([1,"J0:[\"$\",\"@1\",null,{\"assetPrefix\":\"\",\"initialCanonicalUrl\":\"/blog/01-HaxeFlixel-rendering\",\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"blogPost\",\"01-HaxeFlixel-rendering\",\"d\"],{\"children\":[\"\",{}]}]}]},null,null,true],\"initialHead\":null,\"children\":[[[\"$\",\"link\",\"static/media/f884d4ea94220255.p.woff2\",{\"rel\":\"preload\",\"href\":\"/_next/static/media/f884d4ea94220255.p.woff2\",\"as\":\"font\",\"type\":\"font/woff2\",\"crossOrigin\":\"anonymous\"}]],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/97bdc754440853c7.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b76f6b40b08cf2ac.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/cec42fb6dc8e78d9.css\",\"precedence\":\"high\"}],[\"$\",\"link\",\"3\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b8f6d7805f6cf732.css\",\"precedence\":\"high\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"className\":\"__className_9318ce\",\"children\":[[\"$\",\"head\",null,{\"children\":[[\"$\",\"title\",null,{\"children\":\"HaxeFlixel.com\"}],[\"$\",\"meta\",null,{\"name\":\"description\",\"content\":\"HaxeFlixel is a 2D Game Engine that lets you create cross-platform games easier with free, open source technology!\"}],[\"$\",\"meta\",null,{\"name\":\"keywords\",\"content\":\"gamedev, game development, cross-platform, haxe, flixel\"}],[\"$\",\"link\",null,{\"rel\":\"icon\",\"href\":\"/images/favicon.ico\"}],[\"$\",\"script\",null,{\"defer\":true,\"src\":\"https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js\"}],[\"$\",\"script\",null,{\"defer\":true,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"}],[\"$\",\"script\",null,{\"async\":true,\"src\":\"https://platform.twitter.com/widgets.js\",\"charSet\":\"utf-8\"}]]}],[\"$\",\"body\",null,{\"children\":[[\"$\",\"div\",null,{\"className\":\"navbar navbar-inverse navbar-fixed-top\",\"children\":[\"$\",\"div\",null,{\"className\":\"container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"navbar-header\",\"children\":[[\"$\",\"button\",null,{\"data-target\":\".navbar-collapse\",\"data-toggle\":\"collapse\",\"className\":\"navbar-toggle\",\"type\":\"button\",\"children\":[[\"$\",\"span\",null,{\"className\":\"icon-bar\"}],[\"$\",\"span\",null,{\"className\":\"icon-bar\"}],[\"$\",\"span\",null,{\"className\":\"icon-bar\"}]]}],[\"$\",\"@2\",null,{\"href\":\"/\",\"className\":\"navbar-brand\",\"children\":[\"$\",\"@3\",null,{\"src\":{\"src\":\"/_next/static/media/haxeflixel-header.19d77213.png\",\"height\":30,\"width\":169,\"blurDataURL\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAABCAYAAADjAO9DAAAAJklEQVR4nGPsXzz5rSSvbF24v//e379/87OwsDAyMDD8A2IQ/RkAzmIKJsmSsVcAAAAASUVORK5CYII=\",\"blurWidth\":8,\"blurHeight\":1},\"style\":{\"width\":\"169px\",\"height\":\"30px\"},\"alt\":\"HaxeFlixel\",\"width\":\"100\",\"height\":\"100\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"navbar-collapse collapse\",\"children\":[\"$\",\"ul\",null,{\"className\":\"nav navbar-nav\",\"children\":[[\"$\",\"li\",null,{\"className\":\"dropdown \",\"children\":[[\"$\",\"a\",null,{\"href\":\"#\",\"className\":\"dropdown-toggle\",\"data-toggle\":\"dropdown\",\"role\":\"button\",\"aria-haspopup\":\"true\",\"aria-expanded\":\"false\",\"children\":[\"Examples \",[\"$\",\"span\",null,{\"className\":\"caret\"}]]}],[\"$\",\"ul\",null,{\"className\":\"dropdown-menu inverse-dropdown\",\"children\":[[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/demos\",\"children\":\"Demos\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://snippets.haxeflixel.com/\",\"children\":\"Snippets\"}]}]]}]]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/showcase\",\"children\":\"Showcase\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/blog\",\"children\":\"Blog\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"@2\",null,{\"href\":\"/documentation\",\"children\":\"Docs\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"http://api.haxeflixel.com\",\"children\":\"API\"}]}],[\"$\",\"li\",null,{\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/HaxeFlixel/flixel/discussions\",\"children\":\"Forum\"}]}]]}]}]]}]}],[\"$\",\"main\",null,{\"children\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"notFound\":[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"-apple-system, BlinkMacSystemFont, Roboto, \\\"Segoe UI\\\", \\\"Fira Sans\\\", Avenir, \\\"Helvetica Neue\\\", \\\"Lucida Grande\\\", sans-serif\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[[\"$\",\"head\",null,{\"children\":[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}]}],[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"\\n            body { margin: 0; color: #000; background: #fff; }\\n            .next-error-h1 {\\n              border-right: 1px solid rgba(0, 0, 0, .3);\\n            }\\n\\n            @media (prefers-color-scheme: dark) {\\n              body { color: #fff; background: #000; }\\n              .next-error-h1 {\\n                border-right: 1px solid rgba(255, 255, 255, .3);\\n              }\\n            }\\n          \"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":0,\"marginRight\":\"20px\",\"padding\":\"0 23px 0 0\",\"fontSize\":\"24px\",\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\",\"textAlign\":\"left\",\"lineHeight\":\"49px\",\"height\":\"49px\",\"verticalAlign\":\"middle\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":\"14px\",\"fontWeight\":\"normal\",\"lineHeight\":\"49px\",\"margin\":0,\"padding\":0},\"children\":\"This page could not be found.\"}]}]]}]]}],\"childProp\":{\"current\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"childProp\":{\"current\":[\"$\",\"@4\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",[\"blogPost\",\"01-HaxeFlixel-rendering\",\"d\"],\"children\"],\"hasLoading\":false,\"template\":[\"$\",\"@5\",null,{}],\"childProp\":{\"current\":[[],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/3966fc2c7f21f103.css\",\"precedence\":\"high\"}]],\"@6\"],\"segment\":\"\"},\"rootLayoutIncluded\":true}],\"segment\":[\"blogPost\",\"01-HaxeFlixel-rendering\",\"d\"]},\"rootLayoutIncluded\":true}],\"segment\":\"blog\"},\"rootLayoutIncluded\":true}]}],[\"$\",\"footer\",null,{\"className\":\"footer\",\"children\":[\"$\",\"div\",null,{\"className\":\"footer-main\",\"children\":[\"$\",\"div\",null,{\"className\":\" container\",\"children\":[[\"$\",\"div\",null,{\"className\":\"footer-social\",\"children\":[[\"$\",\"iframe\",null,{\"width\":\"120px\",\"scrolling\":\"0\",\"height\":\"20px\",\"frameBorder\":\"0\",\"src\":\"https://ghbtns.com/github-btn.html?user=HaxeFlixel\u0026repo=flixel\u0026type=watch\u0026count=true\u0026size=small\"}],[\"$\",\"a\",null,{\"href\":\"https://twitter.com/haxeflixel\",\"className\":\"twitter-follow-button\",\"data-show-count\":\"true\",\"data-lang\":\"en\",\"data-size\":\"small\",\"children\":\"Follow @haxeflixel\"}],[\"$\",\"a\",null,{\"className\":\"footer-patreon\",\"href\":\"https://www.patreon.com/haxeflixel\",\"title\":\"Support us on Patreon\",\"children\":[\"$\",\"@3\",null,{\"src\":\"/images/patreon-logo-small.svg\",\"alt\":\"Haxeflixel Patreon\",\"title\":\"Patreon\",\"width\":\"40\",\"height\":\"40\"}]}]]}],[\"$\",\"div\",null,{\"className\":\"footer-powered-by\",\"children\":[[\"$\",\"p\",null,{\"children\":\"HaxeFlixel is powered by\"}],[\"$\",\"a\",null,{\"href\":\"http://haxe.org\",\"children\":[\"$\",\"@3\",null,{\"src\":\"/images/haxe.svg\",\"alt\":\"Haxe\",\"title\":\"Haxe\",\"width\":\"40\",\"height\":\"40\"}]}],\"+\",[\"$\",\"a\",null,{\"href\":\"http://openfl.org\",\"children\":[\"$\",\"@3\",null,{\"className\":\"openfl-footer-logo\",\"src\":\"/images/openfl.svg\",\"alt\":\"OpenFL\",\"title\":\"OpenFL\",\"width\":\"40\",\"height\":\"40\"}]}],\"+\",[\"$\",\"a\",null,{\"href\":\"http://flixel.org\",\"children\":[\"$\",\"@3\",null,{\"className\":\"flixel-footer-logo\",\"src\":\"/images/flixel.svg\",\"alt\":\"Flixel\",\"title\":\"Flixel\",\"width\":\"40\",\"height\":\"40\"}]}]]}]]}]}]}]]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"M7:{\"id\":\"3108\",\"name\":\"\",\"chunks\":[\"277:app/blog/[blogPost]/page-d2eac13d9ceb2814\"],\"async\":false}\n"])</script><script>self.__next_f.push([1,"J6:[\"$\",\"@7\",null,{\"frontMatter\":{\"title\":\"Tilesheet rendering\",\"layout\":\"blog-post\",\"postDate\":\"July 31, 2014\"},\"html\":{\"compiledSource\":\"/*@jsxRuntime automatic @jsxImportSource react*/\\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\\nconst {useMDXComponents: _provideComponents} = arguments[0];\\nfunction _createMdxContent(props) {\\n  const _components = Object.assign({\\n    p: \\\"p\\\",\\n    a: \\\"a\\\",\\n    hr: \\\"hr\\\",\\n    pre: \\\"pre\\\",\\n    code: \\\"code\\\",\\n    ul: \\\"ul\\\",\\n    li: \\\"li\\\",\\n    ol: \\\"ol\\\"\\n  }, _provideComponents(), props.components);\\n  return _jsxs(_Fragment, {\\n    children: [_jsxs(_components.p, {\\n      children: [\\\"Hi, \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/gamedevsam\\\",\\n        children: \\\"gamedevsam\\\"\\n      }), \\\" here, I'm a developer and evangelist of HaxeFlixel.\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"The following blog post was written by \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/Beeblerox\\\",\\n        children: \\\"Beeblerox\\\"\\n      }), \\\" (the original creator of HaxeFlixel) and was originally posted on his blog as a two part article (\\\", _jsx(_components.a, {\\n        href: \\\"http://beeblerox.tumblr.com/post/87678385538/tilesheet-rendering-part-1\\\",\\n        children: \\\"part 1\\\"\\n      }), \\\" and \\\", _jsx(_components.a, {\\n        href: \\\"http://beeblerox.tumblr.com/post/87778663958/tilesheet-rendering-part-2-some-details-about-flixel\\\",\\n        children: \\\"part 2\\\"\\n      }), \\\"). In it, he goes into detail on how HaxeFlixel's rendering system is built on top of OpenFL's Tilesheet API.\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"I want to tell you about tilesheet rendering in flixel, which is used on native targets by default (since some of you might me intereseted in it).\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"But let’s start from Tilesheet API and how you work with it (Feel free to skip this part if you know it already).\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Tilesheet class allows you to draw multiple regions of image in one drawcall reasonably fast. These regions can be transformed (rotated, scaled, skewed) and tinted, plus they can have several blend modes (the most usefull is addition mode, which can be used for effects like fire and smoke).\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Let’s assume that you have some image you want to draw - “assets/tiles.png”.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"We are starting from instantiation of Tilesheet object:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"tilesheet = new Tilesheet(Assets.getBitmap(“assets/tiles.png”));\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Then we should define region of image (or tile) we want to draw. This is achieved with addTileRect() method, which takes 2 arguments:\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"the first one is a Rectangle object - it is actual region of image to draw\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"and the second one is a Pont object, which define “center” point of a tile. Added tile will be rotated around this point, if we apply rotation transformation to it. This point should be inside of a tile (or it will be bounded), so if you add tile with the size 32x32 pixels and the center at (50; 16), then actual center point will be at (32; 16).\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Center point argument is optional, and if you omit it then tile will be rotated around it’s middle point.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"// adding tiles to the tilesheet\\\\ntileID1 = tilesheet.addTileRect(newRectangle(0, 0, 32, 32), new Point(16, 16));\\\\ntileID2 = tilesheet.addTileRect(newRectangle(32, 0, 32, 32), new Point(16, 16));\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Then we should have some Graphics object to draw our tiles on.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"sprite = new Sprite();\\\\nLib.current.stage.addChild(sprite);\\\\ngraphicsToUse = sprite.graphics;\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"To draw the tiles on screen we need three things:\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ol, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"Graphics to draw then on\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"Draw flag which tells to the program what tile transformations we want to use on our tiles in this drawcall.\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"The simplest case is no transformation (we just draw rectangular region of image on specified position):\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"drawFlag = 0;\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"You can add tinting:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"drawFlag |= Tilesheet.TILE_RGB;\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"We can add TILE_ALPHA flag to be able to change tile’s alpha:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"drawFlag |= Tilesheet.TILE_ALPHA;\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"There are also \\\", _jsx(_components.code, {\\n        children: \\\"TILE_ROTATION\\\"\\n      }), \\\" and \\\", _jsx(_components.code, {\\n        children: \\\"TILE_SCALE\\\"\\n      }), \\\" (for uniform tile scaling) constants for “simple” transformations of a tile. But if you want to achieve some more complex transformation (like non-uniform scaling or skewing) then you have \\\", _jsx(_components.code, {\\n        children: \\\"TILE_TRANS_2x2\\\"\\n      }), \\\" constant.\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"And finally there are \\\", _jsx(_components.code, {\\n        children: \\\"TILE_BLEND_ADD\\\"\\n      }), \\\" constant for addition blending and \\\", _jsx(_components.code, {\\n        children: \\\"TILE_SMOOTH\\\"\\n      }), \\\" for smoothing scaled up graphics.\\\"]\\n    }), \\\"\\\\n\\\", _jsxs(_components.ol, {\\n      start: \\\"3\\\",\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"We also need actual information about tile’s type, position and transformation. The second argument of drawTiles() method - data array - is responsible for it.\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"The amount of data for each tile depends on drawFlags value:\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"if drawFlags is 0, then you should specify only tile’s position and id:\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"data = [x1, y1, tileID1, x2, y2, tileID2];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"if you’re using uniform scale and rotation then data array will look like this:\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"data = [x1, y1, tileID1, scale1, angle1, x2, y1, tileID2, scale2, angle2];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsx(_components.li, {\\n        children: \\\"if you’re adding tinting and alpha:\\\"\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"data = [x1, y1, tileID1, scale1, angle1, red1, green1, blue1, alpha1,  x2, y1, tileID2, scale2, angle2, red2, green2, blue2, alpha2];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"where red, green, blue and alpha are values between 0 and 1 (result color of each pixel will be product of these coefficients and original pixel colors).\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"and the most complex case is when you’re using \\\", _jsx(_components.code, {\\n          children: \\\"TILE_TRANS_2x2\\\"\\n        }), \\\":\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"data = [x, y, tileID1, a, b, c, d, red, green, blue, alpha];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"where (a, b, c, d) are the transfromation matrix coefficients. You can get their values in two ways:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"a) by using Matrix class. For example, if you want to have non-uniform scale and rotation for your tile, then you can get it this way:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"matrix.identity();\\\\nmatrix.scale(scaleX, scaleY);\\\\nmatrix.rotate(angle);\\\\ndata = [x, y, tileID1, matrix.a, matrix.b, matrix.c, matrix.d, red, green, blue, alpha];\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"b) or manually if you want to make some optimizations. That’s why drawing methods in flixels are so bloated - i just wanted to except some redundant calculations from it.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"So finally you can draw your tiles on the screen:\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.pre, {\\n      children: _jsx(_components.code, {\\n        children: \\\"tilesheet.drawTiles(graphicsToUse, data, false, drawFlags);\\\\n\\\"\\n      })\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"If you want to see some working example, then i recommend you to look at Tiles sample project in nme library: \\\", _jsx(_components.a, {\\n        href: \\\"https://github.com/haxenme/nme/tree/master/samples/20-Tiles\\\",\\n        children: \\\"https://github.com/haxenme/nme/tree/master/samples/20-Tiles\\\"\\n      })]\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"Now when we know everything we need about Tilesheet class, it’s time to talk about flixel renderer a bit.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"As you remember we need Graphics object to render our tiles. FlxCamera objects contain flashSprite:Sprite variable inside which we have canvas:Sprite which graphics we use for rendering on the camera. We need canvas spite to be nested inside flashSprite for easy camera rotations. So if you don’t plan to implement such feature then you might use just one sprite without nesting.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"We also need data to render and render flags, which reflect what types of transformations (like rotation and tinting) apply to rendered tiles. This information is gathered every render cycle: we iterate through each sprite we have in our game. But to keep drawCalls as low as possible we need some sort of batching, which tries to draw everything with the same graphics in one draw call, and when we change graphics it breaks the batch and starts another. This functionality is split between FlxCamera. FlxSprite class and subclasses and DrawStackItem helper class.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"DrawStackItem objects store information about current batch: Tilesheet object to use for rendering, draw data array, information about draw flags (do we need to tint our tiles in the batch, or use blending), and the link to next DrawStackItem object (DrawStackItems are organized into linked list). Each camera have _headOfDrawStack variable which is head of DrawStackItems linked list.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"FlxSprite draw() method does the following:\\\"\\n    }), \\\"\\\\n\\\", _jsxs(_components.ul, {\\n      children: [\\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"it gets DrawStackItem object to use from current FlxCamera. The result of this operation depends on sprite’s graphics, color and blend mode. So if one of these factors isn’t equal to the properties of current DrawStackItem, then current DrawStackItem will be “finalized” (breaks current batch) and new/empty DrawStackItem will be returned to sprite.\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\", _jsxs(_components.li, {\\n        children: [\\\"\\\\n\\\", _jsx(_components.p, {\\n          children: \\\"sprite will add info about itself in current DrawStackItem (positio, tileID, transformation matrix coefficients, tinting and alpha).\\\"\\n        }), \\\"\\\\n\\\"]\\n      }), \\\"\\\\n\\\"]\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"After we iterate through all sprites in our game state, game engine start actual render process.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"It iterate through each camera, clear graphics of cameras, fill them with background color (with graphics.drawRect() method), and then each camera iterate through its list of DrawStackItems. This iteration stage takes DrawStackItem’s tilesheet, draw data, draw flag and render it with drawTiles() method on camera’s canvas.graphics.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.p, {\\n      children: \\\"That is how tilesheet rendering works in flixel. Feel free to ask me questions about it.\\\"\\n    }), \\\"\\\\n\\\", _jsx(_components.hr, {}), \\\"\\\\n\\\", _jsxs(_components.p, {\\n      children: [\\\"You can reach Beeblerox on Twitter \\\", _jsx(_components.a, {\\n        href: \\\"https://twitter.com/teormech\\\",\\n        children: \\\"@teormech\\\"\\n      }), \\\".\\\"]\\n    })]\\n  });\\n}\\nfunction MDXContent(props = {}) {\\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\\n    children: _jsx(_createMdxContent, props)\\n  })) : _createMdxContent(props);\\n}\\nreturn {\\n  default: MDXContent\\n};\\n\",\"frontmatter\":{},\"scope\":{}}}]\n"])</script>